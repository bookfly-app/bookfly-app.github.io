import { collection, getDocs, orderBy, query, where } from "firebase/firestore";
import initializeFirebase from "../backend/backend";
import { getBook, type Book, type ISBN } from "./bookapi";
import { type InternalPost, type Post, type PostId } from "./postapi";
import { fuzzyQuery } from "./util";
import { updateUser, user } from "../backend/auth.svelte";

export type UserId = string;

export type User = {
	username: string;
	email: string;
	id: string;

	// Profile
	displayName: string;
	banner: string;
	picture: string;
	bio: string;
	tags: string[];
	links: {}[];
	currentBook: string | null;
	pronouns: string;

	/** The timestamp, in epoch milliseconds, that this user's account was created. */
	birthmoment: number;

	views: PostId[];
	likes: PostId[];
	shares: PostId[];

	readingList: ISBN[];

	following: UserId[];

	// Preferences
	darkMode: boolean;
};

let { db } = initializeFirebase();

export function usernameErrors(username: string): string[] {
	let errors = [];
	if (username.length > 30) errors.push("Username can't be more than 30 characters");
	if (username.startsWith("-")) errors.push("Username can't start with a hyphen.");
	if (username.endsWith("-")) errors.push("Username can'end with a hyphen.");
	if (!/^[\w\-]*$/.test(username))
		errors.push("Username can only contain letters, numbers, underscores, and hyphens");
	if (/^\d+$/.test(username)) errors.push("Username cannot be only numbers");
	if (/^\-+$/.test(username)) errors.push("Username cannot be only hyphens");
	if (/^\_+$/.test(username)) errors.push("Username cannot be only underscores");
	return errors;
}

export let resolveUser: (user: User) => void;

/**
 * A promise that resolves when the user has loaded. After this promise is resolved, `user()` can
 * be used safely and will return a non-null value. For convenience, the promise returns the user.
 */
export let awaitUser: Promise<User> = new Promise(resolve => {
	resolveUser = resolve;
});

/**
 * Returns a user's "favorite book" which is defined as the book that
 * they have rated the highest. if the user has not rated any books, this
 * returns `null`. If the user has rated at least one book, this is guaranteed
 * to return a non-null value.
 *
 * # Parameters
 *
 * - `user` - The user to get the highest rated book of
 *
 * # Returns
 *
 * The highest rated book from the given user, or `null` if the user hasn't
 * rated any books.
 */
export async function getFavoriteBook(user: User): Promise<Book | null> {
	let posts = (
		await getDocs(
			query(
				collection(db, "posts"),
				where("poster", "==", user.id),
				where("type", "==", "rating"),
			),
		)
	).docs.map(doc => doc.data()) as Post[];
	let books = posts.toSorted((a, b) => b.rating! - a.rating!).map(post => post.books[0]);
	return books.length > 0 ? await getBook(books[0] as unknown as string) : null;
}

export async function getFollowers(user: User): Promise<User[]> {
	const followers: User[] = [];
	(
		await getDocs(query(collection(db, "users"), where("following", "array-contains", user.id)))
	).forEach(doc => followers.push(doc.data() as User));

	return followers;
}

/**
 * Returns the `User` object associated with the given `UserId`. The id is an
 * underlying internal persistent string generated by Firebase, not a human-readable
 * string. To get a user by their username (@), use `getUserFromUsername()`
 *
 * @param id The id of the user to get
 *
 * @returns The user with the given id
 */
export async function getUserFromId(id: UserId): Promise<User> {
	let internalUser = (
		await getDocs(query(collection(db, "users"), where("id", "==", id)))
	).docs[0].data() as User;
	return internalUser;
}

export async function internalUserToUser(user: User): Promise<User> {
	return user;
}

export async function getUserFromUsername(username: string): Promise<User> {
	let user = (
		await getDocs(query(collection(db, "users"), where("username", "==", username)))
	).docs[0].data() as User;
	return user;
}

export async function getNumberOfBooksRead(user: User): Promise<number> {
	return (
		await getDocs(
			query(
				collection(db, "posts"),
				where("poster", "==", user.id),
				where("type", "==", "rating"),
			),
		)
	).docs.length;
}

export async function getUserPosts(user: User): Promise<InternalPost[]> {
	let internalPosts = (
		await getDocs(
			query(
				collection(db, "posts"),
				where("poster", "==", user.id),
				orderBy("timestamp", "desc"),
			),
		)
	).docs.map(doc => doc.data()) as InternalPost[];
	return internalPosts;
}

export async function searchUsers(searchTerm: string): Promise<User[]> {
	if (searchTerm === "") return Promise.resolve([]);
	if (searchTerm.startsWith("@")) {
		const docs = (
			await getDocs(
				query(collection(db, "users"), where("username", "==", searchTerm.substring(1))),
			)
		).docs;
		return docs.length > 0 ? [docs[0].data() as User] : [];
	}
	return fuzzyQuery(searchTerm, "displayName", "users");
}

export const defaultPreferences = {
	darkMode: true,
} as const satisfies Preferences;

type Preferences = {
	darkMode: boolean;
};

export type Preference = keyof Preferences;
export type PreferenceValue<T extends Preference> = Preferences[T];

export function getPreference<Name extends Preference>(name: Name): PreferenceValue<Name> {
	if (user()) return user()![name];

	const fromStorage = localStorage.getItem(`preference-${name}`);
	if (fromStorage) return JSON.parse(fromStorage);

	const preference = defaultPreferences[name];
	localStorage.setItem(`preference-${name}`, JSON.stringify(preference));

	return preference;
}

export async function setPreference<Name extends keyof typeof defaultPreferences>(
	name: Name,
	value: (typeof defaultPreferences)[Name],
): Promise<void> {
	localStorage.setItem(`preference-${name}`, JSON.stringify(value));
	if (user()) await updateUser({ [name]: value });
}
